\documentclass[../../article.tex]{subfiles}
\begin{document}

\sectionabstract{Алгоритм Дейкстры}
{Мы уже поняли как найти кратчайший путь в не взвешенном графе, но для взвешенного графа само понятие кратчайшего пути отличается, а для его поиска в очередной раз немного изменим нашу структуру и алгоритм.}

Взвешенный граф, это граф, ребра которого имеют вес, то есть некое число, ассоциированное с этим ребром (рис. \ref{fig:weightedGraphExample}). Кротчайшим путем называют путь, сумма весов всех ребер которого наименьшая из возможных. Иллюстрация этого на рисунке \ref{fig:compareWeightedPaths}.

\begin{figure}
    \styledgraph{
        a -> [edge label=7] b,
        b -> [edge label=11, inner sep=1pt] c,
        b -> [edge label=2] d,
        d -> [edge label=1, inner sep=1.5pt] e,
        f -> [edge label=7, inner sep=1.5pt] g,
        g -> [edge label=4, near start] h,
        g -> [edge label=8] i,
        a -> [edge label=5] f,
        i -> [bend right=45, edge label=10] f,
        c -> [bend left=45, edge label=5] a,
        h <- [edge label=100] a,
    }
    \caption{Пример взвешенного графа}
    \label{fig:weightedGraphExample}
\end{figure}

\begin{figure}
    \styledgraph{
        a -> [disabledEdge] b [disabledNode],
        b -> [disabledEdge] c [disabledNode],
        b -> [disabledEdge] d [disabledNode],
        d -> [disabledEdge] e [disabledNode],
        f -> [edge label=7, inner sep=1.5pt] g,
        g -> [edge label=4, near start] h,
        g -> [disabledEdge] i [disabledNode],
        a -> [edge label=5] f,
        i -> [bend right=45, disabledEdge] f,
        c -> [bend left=45, disabledEdge] a,
        h <- [edge label=100] a,
    }
    \caption{Пути во взвешенном графе от {\firacodebold a} к {\firacodebold h}}
    \label{fig:compareWeightedPaths}
\end{figure}

И хотя длина пути {\firacodebold [a, h]} в количестве ребер меньше, чем у {\firacodebold [a, f, g, h]}, все таки во взвешенном графе путь {\firacodebold [a, f, g, h]} считается короче, так как длина пути {\firacodebold [a, h]} равна 100 и больше, чем длина пути {\firacodebold [a, f, g, h]}, равная 5 + 7 + 4 = 16.

При таком определении кратчайшего пути мы уже не можем сказать, что поиск в глубину или поиск в ширину даст нам кратчайший путь, так как кратчайший путь теперь зависит не только от графа, но и от веса ребер (хотя в данном примере именно обход в глубину даст кратчайший путь, но это просто совпадение).

\begin{ruledelement}
    \lstset{
        emph={edges},
        emphstyle=\textbf,
        }
        \begin{lstlisting}[caption={Структура для взвешенного графа}, label={lst:weighetGrahStruct}]
interface Edge {
    weight: number;
    nextNode: Node;
}

interface Node {
    id: string;
    edges: Edge[];
    visited?: boolean;
    parent?: Node;
}
    \end{lstlisting}
\end{ruledelement}

\begin{figure*}
    \lstset{
        emph={nextEdge, edges},
        emphstyle=\textbf,
    }
    \begin{ruledelement}
        \begin{lstlisting}[caption={Поиск пути при обходе взвешенного графа в ширину}, label={lst:bfsWeightedRandomPath}]
function traverseGraph() {
    let currentNode = startingNode;
    const nextNodes = [currentNode];

    while (nextNodes.length !== 0) {
        currentNode = nextNodes.shift();
        currentNode.visited = true;

        if (currentNode.data === 'h') {
            let pathNode = currentNode;
            const path = [];

            while(pathNode) {
                path.unshift(pathNode);
                pathNode = pathNode.parent;
            }

            return path;
        }

        const edgesToAdd = currentNode.edges
            .filter(nextEdge => !nextEdge.nextNode.visited)
            .map(nextEdge => {
                nextEdge.nextNode.parent = currentNode;

                return nextEdge.nextNode;
            });

        nextNodes.push(...edgesToAdd);
    }

    return null;
}
        \end{lstlisting}
    \end{ruledelement}

\end{figure*}

Прежде всего, надо в очередной раз поменять структуру данных, представляющую граф. Внимательный читатель заметил, что у нас появились веса ребер, но нет переменных, чтобы их хранить. До этого момента ребра нас не интересовали и были абсолютно равнозначны между собой, теперь же нам нужно выделить отдельную сущность под это (листинг \ref{lst:weighetGrahStruct}).

\subsection{Структура для обхода}

В этой структуре каждая вершина теперь имеет массив ребер {\firacodebold edges}, которые выходят из этой вершины, а каждое ребро {\firacodebold Edge} в этом массиве имеет вес {\firacodebold weight} и ссылку на вершину на другом конце ребра {\firacodebold nextNode}. Таким образом массив {\firacodebold neighbors} нам больше не нужен, информация о соседях перенесена в массив {\firacodebold edges}.

\begin{figure*}
    \begin{ruledelement}
        \lstset{
            emph={getNodeFromQueue, currentNode},
            emphstyle=\textbf,
        }
        \begin{lstlisting}[caption={Отличие алгоритма дейкстры}, label={lst:dijkstraDiffBfs}]
// take the shortest sub-path in the `nextNodes`
function getNodeFromQueue(nextNodes, distances) {
    let nextNodeId = null;
    let resultIndex = -1;

    for (let i = 0; i < nextNodes.length; i++) {
        if (distances.get(nextNodes[i].id) < distances.get(nextNodeId)) {
            nextNodeId = nextNodes[i].id;
            resultIndex = i;
        }
    }

    const [nextNode] = nextNodes.splice(resultIndex, 1);

    return nextNode;
}
        \end{lstlisting}
    \end{ruledelement}
\end{figure*}

\begin{figure*}
    \lstset{
        emph={targetNode, newDistance},
        emphstyle=\textbf,
    }
    \begin{ruledelement}
        \begin{lstlisting}[caption={Первый подход к поиску кратчайшего пути}, label={lst:fullDijsktra}]
function traverseGraph() {
    let currentNode = startingNode;
    const nextNodes = [currentNode];
    const distances = new Map([[startingNode.id, 0]]); (*\label{code:fullDijsktra:distances}*)

    while (nextNodes.length !== 0) {
        currentNode = getNodeFromQueue(nextNodes, distances);
        currentNode.visited = true;

        if (currentNode.id === 'h') { (*\label{code:fullDijsktra:path:start}*)
            let pathNode = currentNode;
            const path = [];

            while(pathNode) {
                path.unshift(pathNode);
                pathNode = pathNode.parent;
            }

            return path;
        } (*\label{code:fullDijsktra:path:end}*)

        for (const nextEdge of currentNode.edges) { (*\label{code:fullDijsktra:edges:start}*)
            const { nextNode } = nextEdge;
            const newDistance = distances.get(currentNode.id) + nextEdge.weight;

            // has another path to `nextNode`, need to select the shortest
            if (distances.has(nextNode.id)) { (*\label{code:fullDijsktra:compare:start}*)
                const knownDistance = distances.get(nextNode.id);

                // the new path is shorter, than the known
                if (knownDistance > newDistance) {
                    distances.set(nextNode.id, newDistance);
                    nextNode.parent = currentNode;
                } (*\label{code:fullDijsktra:compare:end}*)

            // the first known path to `nextNode`
            } else { (*\label{code:fullDijsktra:firstSeen:start}*)
                distances.set(nextNode.id, newDistance);
                nextNode.parent = currentNode;
            } (*\label{code:fullDijsktra:firstSeen:end}*)

            if (!nextEdge.nextNode.visited) {
                nextNodes.push(nextEdge.nextNode);
            }
        } (*\label{code:fullDijsktra:edges:end}*)
    }

    return null;
}
        \end{lstlisting}
    \end{ruledelement}

\end{figure*}

\subsection{Обход взвешенного графа}

Конечно, это все тот же граф и концептуально его обход не изменился, но так как поменялась структура данных, то некоторые детали реализации тоже поменялись. Пример поиска произвольного (не обязательного кратчайшего) пути при обходе в ширину такой структуры показан на листинге \ref{lst:bfsWeightedRandomPath}.

\subsection{Поиск кратчайшего пути}

Прежде чем переходить к самому алгоритму, важно сделать замечание, что если мы каким-то образом найдем кратчайшие пути от начальной вершины до каждой вершины графа, то задача сводится к возврату одного из путей из набора, что тривиально. Что-то подобное и делает алгоритм Дейкстры, с небольшими нюансами, но это мы увидим позже.

Концептуально, сам алгоритм отличается от того же поиска в ширину только порядком обхода! На каждой итерации, вместо первого элемента из очереди nextNodes, мы будем выбирать элемент, кратчайший путь до которого является еще и кратчайшим среди других кратчайших путей до элементов nextNodes. Для этого нам нужно знать кратчайшее расстояние до всех вершин, добавленных в массив nextNodes. Как именно вычисляются эти расстояния мы тоже посмотрим, но если предположить, что такие расстояния у нас есть, выбор следующей вершины будет тривиальным поиском по массиву nextNodes.

Эффективность всего алгоритма можно увеличить, если вместо ручного поиска в массиве использовать оптимизированную очередь с приоритетом. Тем не менее, построение таких очередей выходит за рамки этой статьи, поэтому будем просто перебирать массив.

При таком порядке обхода, как только мы найдем целевую вершину, мы уже будем иметь обратный путь в обратном дереве обхода (рис. ...), который является кратчайшим, а если вы не верите на слово, что этот путь является кратчайшим, то доказательство этого приведено в параграфе на странице \pageref{dijkstraProve}.

Как уже утверждалось выше, чтобы изменить порядок обхода требуемым образом, нам нужно знать кратчайшее расстояние от начальной вершины, до всех, находящихся в массиве nextNodes.

Будем хранить эти расстояния в словаре {\firacodebold distances}, где ключем будет {\firacodebold id} текущей вершины, а значением минимальное расстояние от нее до начальной (листинг \ref{lst:fullDijsktra}, строка \ref{code:fullDijsktra:distances}).

\subimport{/}{dijkstra-steps.tex}

Как и в предыдущем алгоритме поиска пути в ширину (листинг \ref{lst:bfsWeightedRandomPath}), как только мы нашли целевую вершину, наступает время восстановления искомого пути и завершения алгоритма (строки \ref{code:fullDijsktra:path:start} - \ref{code:fullDijsktra:path:end}).

Оставшаяся часть алгоритма из листинга \ref{lst:bfsWeightedRandomPath} (выставление предшественника в поле {\firacodebold parent}) тоже присутствует, но видоизменилась. На строках с \ref{code:fullDijsktra:edges:start} по \ref{code:fullDijsktra:edges:end} мы обрабатываем каждое исходящее ребро {\firacodebold nextEdge} текущей вершины {\firacodebold currentNode}. В случае, если ребро ведет до еще ранее не просмотренной вершины (для нее нету значения в словаре {\firacodebold distances}, строки \ref{code:fullDijsktra:firstSeen:start}-\ref{code:fullDijsktra:firstSeen:end}), считаем, что кратчайшее расстояние до этой вершины равно кратчайшему расстоянию до предшественника вершины {\firacodebold nextNode}, которым является вершина {\firacodebold nextNode}, плюс длина обрабатываемого ребра {\firacodebold nextEdge}. В противном случае (строки \ref{code:fullDijsktra:compare:start}-\ref{code:fullDijsktra:compare:end}), у нас есть два пути, длины которых нам надо сравнить и выбрать кротчайший, другими словами, оставить все как есть, если новый найденный путь длиннее или равен текущему, и обновить путь, если он короче. Ключевым здесь является то, что мы не только обновили расстояние в словаре {\firacodebold distances}, но и поле {\firacodebold parent} для {\firacodebold nextNode}, ведь чтобы действительно прийти в nextNode по новому найденному кратчайшему пути, надо идти туда из текущей обрабатываемой вершины.

Как и прежде, ссылки {\firacodebold parent} формируют обратное дерево обхода, только теперь его форма будут зависеть не только от порядка обхода, как мы видели раньше для обходов в глубину и ширину, но и от весов ребер, так как мы будем "переставлять" ссылку {\firacodebold parent} в зависимости от того, какой {\firacodebold parent} предоставляет более короткий путь.

Раскадровка построения обратного дерева обхода для нашего случая приведена на рисунке \ref{fig:reverseTreeDijkstra}, а "перестановку" ссылки parent можно увидеть для вершины h при переходе от шага 6 (рис. \ref{fig:reverseTreeDijkstra6}) к шагу 7 (рис. \ref{fig:reverseTreeDijkstra7}).

\begin{figure}
    \centering
    \begin{styledtikz}
        \begin{scope}[local bounding box=graph1, spring layout]
            \begin{scope}[every node/.style={baseNode}]
                \node (a) {\splittext{a}{100}};
                \node (start) [reverseNode] {start};
                \node (b) {b};
                \node (c) [reverseNode] {c};
                \node (d) [disabledNode, dashedPath] {};
                \node (e) [disabledNode, dashedPath] {};
                \node (f) [disabledNode, dashedPath] {};
                \node (g) [disabledNode, dashedPath] {};
                \node (cc) [disabledNode, dashedPath] {};
                \node (end) {end};
            \end{scope}

            \styledgraphraw[2.1cm][spring layout]{
                (start) -> [reverseEdge, edge label=50] (b),
                (start) -> [reverseEdge, edge label=10] (c),
                (c) -> [reverseEdge, edge label=20, near start] (a),
                (c) -> [reverseEdge, edge label=10] (end),

                (b) -> [disabledEdge, dashedPath] (e) -> [disabledEdge, dashedPath] (f) -> [disabledEdge, dashedPath] (g) -> [disabledEdge, dashedPath] (end),

                (a) -> [disabledEdge, dashedPath] (cc) -> [disabledEdge, dashedPath] (d) -> [disabledEdge, dashedPath] (end),
                (end),
            };
            % \node[inner sep=0pt, ellipse,fit=(start) (c) (end)] {};
            % \begin{scope}[
            %     transparency group,
            %     opacity=0.10,
            % ]
            %     \draw [
            %         line width=1.2cm,
            %         {Round Cap []}-{Round Cap []},
            %         draw=accentColor,
            %     ]
            %     (node cs:name=start, anchor=center)
            %         -- (node cs:name=c, anchor=center)
            %         -- (node cs:name=end, anchor=center);
            % \end{scope}
            % \begin{scope}[
            %     transparency group,
            %     opacity=0.20,
            % ]
            %     \draw [
            %         line width=3mm,
            %         {Round Cap []}-{Round Cap []. Fast Round[] Fast Round[]},
            %         rounded corners,
            %         draw=secondaryAccentColor,
            %     ]
            %     (node cs:name=start, anchor=center)
            %         -- (node cs:name=c, anchor=center)
            %         -- (node cs:name=a, anchor=center)
            %         -- (node cs:name=c, anchor=center)
            %         -- (node cs:name=d, anchor=center)
            %         -- (node cs:name=end, anchor=center);
            % \end{scope}
            % \begin{scope}[
            %     transparency group,
            %     opacity=0.20,
            % ]
            %     \draw [
            %         line width=1.2cm,
            %         {Round Cap []}-{Round Cap []},
            %         rounded corners,
            %         draw=secondaryColor,
            %     ]
            %     (node cs:name=start, anchor=center)
            %         -- (node cs:name=b, anchor=center)
            %         -- (node cs:name=e, anchor=center)
            %         -- (node cs:name=f, anchor=center)
            %         -- (node cs:name=g, anchor=center)
            %         -- (node cs:name=end, anchor=center);
            % \end{scope}
                %     \node (GG) at (node cs:name=end) {};
                %     \node (GG) at (node cs:name=c) {};
        \end{scope}

        \tikzset{pics/centered/.style={code={
            \begin{scope}[
                node distance=7pt,
            ]
                \node [baseNode, below=1cm of graph1.south, minimum size=5pt] (abc) {};
                \node [right=5pt of abc, font=\footnotesize] {добавленные в {\firacodebold distances}};
                \node [baseNode, below=of abc, minimum size=5pt, disabledNode] (bca) {};
                \node [right=5pt of bca,font=\footnotesize] {части возможного {\firacodebold PathX}};
                \node [baseNode, below=of bca, minimum size=5pt, reverseNode] (hhh) {};
                \node [right=5pt of hhh, font=\footnotesize] {посещенные ({\firacodebold visited = true})};
            \end{scope}
        }}}

        \matrix[at={(graph1.south)}] {
            \pic {centered};\\
        };
    \end{styledtikz}
    \caption{Пути во взвешенном графе от {\firacodebold a} к {\firacodebold h}}
    \label{fig:dijkstraProve}
\end{figure}

\subsection{Доказательство верности} \label{dijkstraProve}

Прежде чем перейти к формальному доказательству, можно заметить, что проблема, описанная для первого алгоритма, показанного в листинге \ref{lst:fullDijsktra}, заключалась в том, что мы попали в вершину h по более длинному пути [a, h] раньше, чем по более короткому [a, f, g, h], и из-за того, что словарь distances перестал быть валидным хранилищем кратчайших расстояний от начальной вершины до любой другой обойденной вершины в графе, а алгоритм Дейкстры исключает такую возможность.

Выбирая следующую вершину для обхода из nextNodes, мы по сути выбираем следующий путь, от которого мы продолжим анализ. Предположим, в какой-то момент алгоритм совершил ошибку и вначале попал в вершину end по более длинному пути PathY, чем тот, который еще не открыт (PathX). Это означало бы, что PathX включает в себя как минимум один из уже открытых путей, но все открытые пути по определению алгоритма должны быть длиннее PathY (на каждом этапе мы всегда выбираем самый короткий путь), значит PathX должен включать в себя путь, более длинный чем PathY, что означает, что PathX не может быть короче PathY. Следовательно, и совершение алгоритмом ошибки невозможно.

\end{document}
