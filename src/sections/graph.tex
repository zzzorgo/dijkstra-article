\documentclass[../article.tex]{subfiles}
\begin{document}
% todo привести терминологию в порядок (вершина/элемент)
% todo заменить дефис на тире

\sectionabstract{Обход графов}
{Как и в случае с деревьями, графы обходят не просто так. Посмотрим как найти искомую вершину в графе и проведем аналогию с обходом деревьев.}

\subsection{Структура для обхода}

В процессе того как мы будем двигаться по этому разделу, структура, которую мы будем использовать для объявления графа будет меняться. Начнем с максимально простой и похожей на ту, что мы использовали для деревьев.

\begin{ruledelement}
    \lstset{
        emph={startingNode, neighbors, visited},
        emphstyle=\textbf,
    }
    \begin{lstlisting}[caption={Структура вершины графа}, label={lst:graphStructureTreeLike}]
interface Node {
    data: string;
    neighbors: Node[];
    visited?: boolean;
}


const startingNode: Node = // ...
    \end{lstlisting}
\end{ruledelement}

Как видно из листинга \ref{lst:graphStructureTreeLike}, поменялось не очень много. В классическом понимании у графа нет корня, но в наших задачах есть вершина {\firacodebold startingNode}, с которой мы начинаем обход. У элементов нет потомков, только соседние элементы {\firacodebold neighbors}. Тем не менее, если исключить переименовывание это та же структура, а значит и обойти ее можно так же?

На самом деле не совсем так. Из определения деревьев следует ограничение на то, какие именно элементы могут быть потомками для других элементов. То есть например вершина-потомок не может иметь в качестве своего потомка своего же родителя. Наличие же такой связи в итоговом дереве автоматически превратит дерево в граф.

А про поле {\firacodebold visited} поговорим позже.

\begin{figure}
    \styledgraph{
        a -> { b -> { c , d -> e }, f -> g -> { h , i }},
        i -> [bend right=45] f,
        c -> [bend left=45] a,
    }
    \caption{Пример графа}
    \label{fig:treeTurningToGraph}
\end{figure}

На рисунке \ref{fig:treeTurningToGraph} хорошо видно как это происходит при, например, добавление двух связей (ребер): от {\firacodebold c} к {\firacodebold a} и от {\firacodebold i} к {\firacodebold f}. Так же на это рисунке более явно указано направлении связи, где стрелка идет от элемента-родителя до элемента-потомка. Добавление этих связей в коде можно выразить в коде (листинг \ref{lst:treeTurningToGraph}).

\begin{ruledelement}
    \lstset{
        emph={neighbors,push},
        emphstyle={\textbf}
    }
    \begin{lstlisting}[caption={Добавление связей превращающих дерево в грфа}, label={lst:treeTurningToGraph}]
// `visited` field is omitted as
// it is optional and not used yet
const nodeI = {
    data: 'i',
    neighbors: [],
};
const nodeH = {
    data: 'h',
    neighbors: [],
};
const nodeE = {
    data: 'e',
    neighbors: [],
};
const nodeG = {
    data: 'g',
    neighbors: [nodeH, nodeI],
};
const nodeD = {
    data: 'd',
    neighbors: [nodeE],
};
const nodeC = {
    data: 'c',
    neighbors: [],
};
const nodeF = {
    data: 'f',
    neighbors: [nodeG],
};
const nodeB = {
    data: 'b',
    neighbors: [nodeC, nodeD],
};
const nodeA = {
    data: 'a',
    neighbors: [nodeB, nodeF],
};

nodeI.neighbors.push(nodeF);
nodeC.neighbors.push(nodeA);
    \end{lstlisting}
\end{ruledelement}


Что ж, после этих манипуляций структура дерева не сильно поменялась, как и алгоритм ее обхода, хоть это теперь и граф.

\subsection{Обход в глубину}

Предположим, что мы не стали бы менять наш алгоритм и подсунули ему наш граф. В таком случае все работает так же как и для дерева до момента, когда основной цикл дойдет до обработки {\firacodebold nodeC}. В момент обработки {\firacodebold nodeC} алгоритм добавит всех потомков, то есть включая {\firacodebold nodeA}. То есть мы снова вернемся к началу и снова добавим всех потомков {\firacodebold nodeA} на обработку, а дальше потомков потомков, то есть {\firacodebold nodeC} тоже. В итоге получается бесконечный цикл.

Если же мы исключим из обхода уже обработанные вершины, то второй раз в {\firacodebold nodeA} мы не попадем, собственно это и есть все отличие (листинг \ref{lst:graphDfs}).

В момент обработки очередного элемента {\firacodebold currentNode} мы выставляем флаг {\firacodebold visited} в значение {\firacodebold true} (строка 9), чтобы на последующих итерациях не добавлять ее в стек {\firacodebold nextNodes} (строки 15-18). Порядок обхода в данном случае не отличается от порядка обхода того же дерева и можно посмотреть на рисунке \ref{fig:treeDfsOrder}.

\subsection{Обход в ширину}

Кажется довольно очевидно, что обход ширину, как и для деревьев, будет отличаться лишь одной сточкой, изменяя лишь порядок обхода, который можно посмотреть на рисунке \ref{fig:treeBfsOrder}.

\begin{ruledelement}
    \lstset{
        emph={shift},
        emphstyle=\textbf,
        firstnumber=8,
    }
    \begin{lstlisting}[caption={Отличие обхода в ширину от обхода в глубину}, label={lst:graphBfsDiff}]
// currentNode = nextNodes.pop();
currentNode = nextNodes.shift();
    \end{lstlisting}
\end{ruledelement}

\begin{figure*}
    \lstset{
        emph={traverseGraph, visited, filter},
        emphstyle=\textbf,
    }
    \begin{ruledelement}
        \begin{lstlisting}[caption={Обход графа в глубину}, label={lst:graphDfs}]
const startingNode = nodeA;

function traverseGraph() {
    let currentNode = null;
    const nextNodes = [startingNode];

    while (nextNodes.length !== 0) {
        currentNode = nextNodes.pop();
        currentNode.visited = true;

        if (currentNode.data === 'target data') {
            return currentNode;
        }

        const nodesToAdd = currentNode.neighbors
            .filter(nextNode => !nextNode.visited);

        nextNodes.push(...nodesToAdd);
    }

    return null;
}
        \end{lstlisting}
    \end{ruledelement}

\end{figure*}

\subsection{Поиск пути}

Помимо поиска отдельно взятой вершины графа, часто бывает полезно найти путь до этой вершины от той вершины, с которой мы начинали ({\firacodebold startingNode}). Но что такое найти путь? Будем считать, что путь это связный список, начало которого это все та же {\firacodebold startingNode}, конец - целевая вершина, а в середине все ноды по пути. Чтобы у нас было больше одного возможного пути добавим еще одно ребро {\firacodebold a -> e}.

Предположим, что мы ищем путь от вершины {\firacodebold a} до вершины {\firacodebold e} (рис. \ref{fig:pathExposure})

\ref{fig:pathExposure2}

\begin{figure*}
    \centering
    \begin{subfigure}{0.32\textwidth}
        \styledgraph{
            1 -> {6 -> {9, 7 -> 8}, 2 -> 3 -> {5, 4}}
        }
        \caption{cba}
        \label{fig:first}
    \end{subfigure}
    \begin{subfigure}{0.32\textwidth}
        \styledgraph{
            a` <- {b` <- {c`, d` <- e`}, f` <- g` <- {h`, i`}}
        }
        \caption{abc}
        \label{fig:second}
    \end{subfigure}
    \begin{subfigure}{0.32\textwidth}
        \styledgraph{
            a -> [disabledEdge] b [disabledNode],
            b -> c [disabledNode],
            b -> [disabledEdge] d [disabledNode],
            d -> [disabledEdge] e [disabledNode],
            f -> g,
            g -> h,
            g -> [disabledEdge] i [disabledNode],
            a -> f,
            b -> [disabledEdge] c,
            i -> [bend right=45, disabledEdge] f,
            c -> [bend left=45, disabledEdge] a,
            h <- a,
        }
        \caption{def}
        \label{fig:third}
    \end{subfigure}
    \caption{Hbc}
\end{figure*}

\begin{figure}[H]
    \styledgraph{
        a -> {
            b -> { c [disabledNode], d -> e },
            f [disabledNode] -> [disabledEdge]
                g [disabledNode] -> [disabledEdge] {
                    h [disabledNode],
                    i [disabledNode]
                }
        },
        a -> [disabledEdge] f,
        b -> [disabledEdge] c,
        i -> [bend right=45, disabledEdge] f,
        c -> [bend left=45, disabledEdge] a,
        e <- [bend right=22] a,
    }
    \caption{Пути в графе от {\firacodebold a} к {\firacodebold e}}
    \label{fig:pathExposure}
\end{figure}

\end{document}
