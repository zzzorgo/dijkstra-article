\documentclass[../article.tex]{subfiles}
\begin{document}
% todo привести терминологию в порядок (вершина/элемент)
% todo заменить дефис на тире

\sectionabstract{Обход графов}
{Как и в случае с деревьями, графы обходят не просто так. Посмотрим как найти искомую вершину в графе и проведем аналогию с обходом деревьев.}

\subsection{Структура для обхода}

В процессе того как мы будем двигаться по этому разделу, структура, которую мы будем использовать для объявления графа будет меняться. Начнем с максимально простой и похожей на ту, что мы использовали для деревьев.

\begin{ruledelement}
    \lstset{
        emph={startingNode, neighbors},
        emphstyle=\textbf,
    }
    \begin{lstlisting}[caption={Структура врешины графа}, label={lst:graphStructureTreeLike}]
interface Node {
    data: string;
    neighbors: Node[];
}


const startingNode: Node = // ...
    \end{lstlisting}
\end{ruledelement}

Как видно из листинга \ref{lst:graphStructureTreeLike}, поменялось не очень много. В классическом понимании у графа нет корня, но в наших задачах есть вершина {\firacodebold startingNode}, с которой мы начинаем обход. У элементов нет потомков, только соседние элементы {\firacodebold neighbors}. Тем не менее, если исключить переименовывание это та же структура, а значит и обойти ее можно так же?

На самом деле не совсем так. Из определения деревьев следует ограничение на то, какие именно элементы могут быть потомками для других элементов. То есть например вершина-потомок не может иметь в качестве своего потомка своего же родителя. Наличие такой связи автоматически превратит дерево в граф.

\end{document}
